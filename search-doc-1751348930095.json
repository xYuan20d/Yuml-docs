{"searchDocs":[{"title":"第一条帖子","type":0,"sectionRef":"#","url":"/blog/post1","content":"✨ 欢迎来到本站的第一篇帖子！🎉 如果你不嫌麻烦，欢迎点击右下方的「💬」按钮 👉 登录一下，留言「到此一游」，让我知道你来过 Ciallo～(∠・ω&lt; )⌒★","keywords":"","version":null},{"title":"小案例","type":0,"sectionRef":"#","url":"/docs/demo","content":"小案例","keywords":"","version":"Next"},{"title":"插件SDK","type":0,"sectionRef":"#","url":"/docs/plugin-sdk","content":"插件SDK 欢迎来到插件SDK目录！这里包含插件开发包的API的文档。","keywords":"","version":"Next"},{"title":"插件文档","type":0,"sectionRef":"#","url":"/docs/plugin","content":"插件文档 欢迎来到插件文档目录！这里包含插件的安装、使用、开发等文档。","keywords":"","version":"Next"},{"title":"Yuml简介","type":0,"sectionRef":"#","url":"/docs/intro","content":"","keywords":"","version":"Next"},{"title":"🧠 什么是 Yuml？​","type":1,"pageTitle":"Yuml简介","url":"/docs/intro#-什么是-yuml","content":" Yuml 是一个基于 YAML 语法结构构建的声明式 UI 和元编程语言，它的设计理念是：  摆脱 HTML + JS 的限制，实现全平台可嵌入的数据交互式编程体验  类似 XML/HTML 的结构，但具备控制流、模块系统、动态表达式等能力。既可以用来写页面 UI，也可以作为逻辑脚本语言运行。支持 Python、Lua 的无缝嵌入，也能完全脱离传统语言独立运行。  ","version":"Next","tagName":"h2"},{"title":"🔥 特点一览​","type":1,"pageTitle":"Yuml简介","url":"/docs/intro#-特点一览","content":" ✅ 事件驱动编程✅ 模块系统（可导入依赖包和组件）✅ 全局变量、作用域、数据绑定机制✅ 字符串模板渲染（{&lt; &gt;} / {&lt;&lt; &gt;&gt;} 支持表达式嵌入）✅ 插件化机制，支持扩展组件、拖拽式可视化编辑✅ 支持控制流（if / for / break / continue）✅ 自定义语法指令  ","version":"Next","tagName":"h2"},{"title":"⚡ 新版性能革新​","type":1,"pageTitle":"Yuml简介","url":"/docs/intro#-新版性能革新","content":" Yuml 引入了编译执行机制 + 惰性加载特性，带来飞跃式的性能提升：  ","version":"Next","tagName":"h2"},{"title":"🚀 启动速度更快​","type":1,"pageTitle":"Yuml简介","url":"/docs/intro#-启动速度更快","content":" YAML 不再每次都通过 jinja2 + ruamel.yaml 解析。支持将 .yaml 编译为 .ybc（Yuml Byte Code），启动速度提升数倍，尤其是结构复杂时效果更明显！  ","version":"Next","tagName":"h3"},{"title":"🧊 支持惰性加载，解决内存占用​","type":1,"pageTitle":"Yuml简介","url":"/docs/intro#-支持惰性加载解决内存占用","content":" 旧版本运行时会将整个 YAML 结构一次性转为 dict 并加载进内存；新版使用 SQLite 存储结构，结合 按需键值读取机制，大幅降低内存峰值占用。每次只会访问你实际用到的那一部分逻辑，实现真正意义上的“边加载边运行”。  ","version":"Next","tagName":"h3"},{"title":"🛠️ 双模式运行（灵活适配场景）​","type":1,"pageTitle":"Yuml简介","url":"/docs/intro#️-双模式运行灵活适配场景","content":" 模式\t说明\t适合场景直接运行 .yaml\t原始解释执行，保留动态性\t开发、调试 编译后运行 .ybc\t编译为字节码后运行\t上线部署、性能场景  🎯 你可以把 .ybc 理解为一个 SQLite 驱动的结构化 AST，运行时只需查询所需键值，而无需将整个字典载入内存。  ","version":"Next","tagName":"h3"},{"title":"简单示例​","type":1,"pageTitle":"Yuml简介","url":"/docs/intro#简单示例","content":" 你可以像写 YAML 一样写 UI 元素，也可以写函数、变量、模块：  run: \\&gt;hello_world: &quot;Hello World!&quot; LOG: &quot;{&lt; hello_world &gt;}&quot; # 输出Hello World!  ","version":"Next","tagName":"h2"},{"title":"📦 安装 Yuml","type":0,"sectionRef":"#","url":"/docs/install","content":"","keywords":"","version":"Next"},{"title":"使用 Git 克隆安装​","type":1,"pageTitle":"📦 安装 Yuml","url":"/docs/install#使用-git-克隆安装","content":" Yuml 当前仍处于测试阶段，尚未发布至 PyPI，建议通过 Git 克隆源代码来使用：  ","version":"Next","tagName":"h2"},{"title":"克隆仓库​","type":1,"pageTitle":"📦 安装 Yuml","url":"/docs/install#克隆仓库","content":" git clone https://github.com/xYuan20d/Yuml.git cd Yuml   ","version":"Next","tagName":"h3"},{"title":"安装依赖​","type":1,"pageTitle":"📦 安装 Yuml","url":"/docs/install#安装依赖","content":" pip install -r requirements.txt   警告 请确保你已安装 Python 3.10 或以上版本。 ","version":"Next","tagName":"h3"},{"title":"使用教程","type":0,"sectionRef":"#","url":"/docs/useDoc","content":"使用教程 欢迎来到使用文档目录！这里包含Yuml的使用教程文档。","keywords":"","version":"Next"},{"title":"前后端交互","type":0,"sectionRef":"#","url":"/docs/使用教程/full","content":"前后端交互 待更新","keywords":"","version":"Next"},{"title":"🌱 根节点与事件机制","type":0,"sectionRef":"#","url":"/docs/使用教程/events","content":"","keywords":"","version":"Next"},{"title":"📦 什么是块（函数）​","type":1,"pageTitle":"🌱 根节点与事件机制","url":"/docs/使用教程/events#-什么是块函数","content":" Yuml 不使用传统的 function 或 def 等关键字来声明函数， 而是通过判断块名是否与事件名重名，来区分：  事件块：系统自动触发执行自定义块：需要手动调用，作为通用逻辑复用结构  ","version":"Next","tagName":"h2"},{"title":"✨ 示例​","type":1,"pageTitle":"🌱 根节点与事件机制","url":"/docs/使用教程/events#-示例","content":" windowCreated: windowSize: {width: 800, height: 600} CALL_BLOCK: testBlock testBlock: LOG: &quot;块被调用&quot;   说明：  windowCreated 是一个与事件同名的块 → 会在窗口创建时被系统自动触发testBlock 是一个自定义逻辑块 → 需要通过 CALL_BLOCK 主动调用  提示 避免将自定义块命名为下列系统事件名，否则它将会被识别为事件块，无法被正常复用。 自定义块常用于组织业务逻辑，支持被 callBlock / CALL_BLOCK 等元素调用。    ","version":"Next","tagName":"h3"},{"title":"⚙️ 常见事件块一览（自动触发）​","type":1,"pageTitle":"🌱 根节点与事件机制","url":"/docs/使用教程/events#️-常见事件块一览自动触发","content":" 事件名\t触发时机run\t当应用开始运行时触发 windowCreated\t当窗口首次 show() 时触发 windowShowed\t当窗口被显示（从隐藏变可见）时 windowHidden\t当窗口被隐藏 windowResized\t当窗口尺寸发生变化时触发 windowMoved\t当窗口被移动时触发 windowClosed\t用户点击关闭按钮时触发  事件块的结构与普通块完全一致，唯一区别是： 事件块会被系统自动调用，无需你手动调用。  小贴士 当开始运行时，会触发run事件，请在上面写创建窗口的代码触发windowCreated事件!    如需定义你自己的事件响应逻辑，只需新建一个块，命名为以上事件名之一即可。 ","version":"Next","tagName":"h2"},{"title":"🐍 Yuml Python API 简介","type":0,"sectionRef":"#","url":"/docs/使用教程/python_api","content":"","keywords":"","version":"Next"},{"title":"📌 核心接口：LoadYmlFile​","type":1,"pageTitle":"🐍 Yuml Python API 简介","url":"/docs/使用教程/python_api#-核心接口loadymlfile","content":" LoadYmlFile( file_name: str, # Yuml 文件路径 app: QApplication, # Qt 应用实例 load_str: bool = False, # 是否以字符串方式加载内容（而非文件路径） _p: QWidget | None = None # 父窗口对象（可选） ... # 这里不展示Yuml底层交互参数 )   该函数会自动识别并执行 YAML 中的根块，如 windowCreated 等。    ","version":"Next","tagName":"h2"},{"title":"🚀 示例用法​","type":1,"pageTitle":"🐍 Yuml Python API 简介","url":"/docs/使用教程/python_api#-示例用法","content":" from PySide6.QtWidgets import QApplication from os import environ # 必须在导入 Yuml 前设置窗口样式 environ[&quot;__YuQt_WindowStyle&quot;] = &quot;YW_root&quot; from YUML.Yuml import LoadYmlFile app = QApplication([]) # 加载 Yuml 文件并运行 LoadYmlFile(&quot;main.yaml&quot;, app) # 注意：不要使用 app.exec() # Yuml 内部已集成 Qt 事件循环管理，建议在 YAML 中使用 $app::run 代替！     ","version":"Next","tagName":"h2"},{"title":"📎 注意事项​","type":1,"pageTitle":"🐍 Yuml Python API 简介","url":"/docs/使用教程/python_api#-注意事项","content":" LoadYmlFile 是 Yuml 与 Python 的桥梁入口建议统一在 main.yaml 中使用 windowCreated 等事件块进行初始化 ","version":"Next","tagName":"h2"},{"title":"控制流","type":0,"sectionRef":"#","url":"/docs/使用教程/OR","content":"控制流 待更新","keywords":"","version":"Next"},{"title":"🧱 Yuml 元素机制详解 (main_block)","type":0,"sectionRef":"#","url":"/docs/使用教程/mainBlocks","content":"","keywords":"","version":"Next"},{"title":"🧩 块的语义构成​","type":1,"pageTitle":"🧱 Yuml 元素机制详解 (main_block)","url":"/docs/使用教程/mainBlocks#-块的语义构成","content":" 每个块的结构如下：  块名: 元素名: 参数  其中：  块名 是根节点，用于标识一个 Block；元素名 是具体要执行的功能；参数 是对应的配置或调用参数。    ","version":"Next","tagName":"h2"},{"title":"🧩 cw控制器​","type":1,"pageTitle":"🧱 Yuml 元素机制详解 (main_block)","url":"/docs/使用教程/mainBlocks#-cw控制器","content":" 在 Yuml 中，所有组件类元素（如按钮、输入框、标签等）并不由 main_block 直接处理，而是交由一个名为 cw控制器 的内部控制器负责构建与管理。  cw控制器是 Yuml 框架的 组件调度中心，它：  封装了常用组件的创建逻辑（如 button, label, listBox, input 等）；统一处理每个组件中的组件元素（如 show, onClicked, size, QssStyle 等）；实现了组件逻辑的解耦与复用，保证每类组件的独立行为和生命周期管理。  当你在 Yuml 中写下如下内容时：  button: myButton: show: true onClicked: sayHello   main_block 会调用 cw.button(...) 来创建 QPushButton，并将 show、onClicked 等组件元素委托给 cw控制器 进一步解析和执行。  通过 cw控制器，Yuml可以轻松处理组件插件扩展等。  ","version":"Next","tagName":"h2"},{"title":"⚙️ 支持的元素与功能​","type":1,"pageTitle":"🧱 Yuml 元素机制详解 (main_block)","url":"/docs/使用教程/mainBlocks#️-支持的元素与功能","content":" ","version":"Next","tagName":"h2"},{"title":"📐 窗口类元素​","type":1,"pageTitle":"🧱 Yuml 元素机制详解 (main_block)","url":"/docs/使用教程/mainBlocks#-窗口类元素","content":" 元素名\t功能\t参数说明windowSize\t设置主窗口大小\twidth, height 字段 windowTitle\t设置窗口标题\t字符串 windowIcon\t设置窗口图标\t图标路径 globalStyle\t设置全局样式表（QSS）\tQSS 字符串 QssStyle\t等价于 globalStyle\t同上    ","version":"Next","tagName":"h3"},{"title":"🧱 基础 UI 元素（由cw控制器处理）​","type":1,"pageTitle":"🧱 Yuml 元素机制详解 (main_block)","url":"/docs/使用教程/mainBlocks#-基础-ui-元素由cw控制器处理","content":" 元素名\t功能button\t创建按钮 label\t创建标签 listBox\t创建列表框 input\t创建输入框 YUML_WIDGET\t加载子 Yuml 界面（嵌套）    ","version":"Next","tagName":"h3"},{"title":"📦 容器元素​","type":1,"pageTitle":"🧱 Yuml 元素机制详解 (main_block)","url":"/docs/使用教程/mainBlocks#-容器元素","content":" 元素名\t功能box\t创建多个 QWidget 容器并迁移内部元素    ","version":"Next","tagName":"h3"},{"title":"🧰 通用逻辑元素​","type":1,"pageTitle":"🧱 Yuml 元素机制详解 (main_block)","url":"/docs/使用教程/mainBlocks#-通用逻辑元素","content":" 元素名\t功能LOG\t控制台打印 RETURN\t返回值到外部 CALL_BLOCK\t调用其他块（支持字符串或列表） callBlock\t同上，另一种语法形式 HOOK\t执行钩子函数，将结果挂载到 hook 名 DELETE\t删除全局变量 IMPORT\t设置导入路径（用于模块/插件系统）    ","version":"Next","tagName":"h3"},{"title":"🔁 控制流结构​","type":1,"pageTitle":"🧱 Yuml 元素机制详解 (main_block)","url":"/docs/使用教程/mainBlocks#-控制流结构","content":" 元素名\t功能WHILE\t条件循环，支持 COND / CODE / ELSE FOR\t遍历结构，支持 ITER / CODE / NAME / ELSE IF\t条件判断，支持多个条件块与 ELSE 分支 CONTINUE\t跳过当前循环 BREAK\t跳出当前循环    ","version":"Next","tagName":"h3"},{"title":"🧬 脚本执行元素​","type":1,"pageTitle":"🧱 Yuml 元素机制详解 (main_block)","url":"/docs/使用教程/mainBlocks#-脚本执行元素","content":" 元素名\t功能PythonScript\t执行 Python 脚本 LuaScript\t执行 Lua 脚本 YuanGuiScript\t执行 YuanGui 自定义脚本    ","version":"Next","tagName":"h3"},{"title":"⛓️ 特殊符号块名说明​","type":1,"pageTitle":"🧱 Yuml 元素机制详解 (main_block)","url":"/docs/使用教程/mainBlocks#️-特殊符号块名说明","content":" 当块名以以下前缀符号开头时，会触发特殊语义：  前缀符号\t功能语义\\=\t设置全局变量（字符串值） \\&gt;\t设置全局变量（表达式或 .accept） \\#\t执行代码块作为 HOOK $\t调用全局变量（函数或对象链式调用）  示例：  \\=myVar: 123 \\&gt;result: &quot;1 + 2&quot; $button1::move: [[100, 100], {}]     备注 YAML 标准语法不允许在同一作用域内定义多个同名元素。 为了解决这个限制，Yuml 提供了重复元素名的支持机制： 你可以通过在元素名后添加 _任意数字 的方式，实现多次使用相同的元素： LOG: 1 LOG_2: 2 LOG_3: 3 它们将被视为同一种元素依次执行。  ","version":"Next","tagName":"h3"},{"title":"组件元素和普通元素​","type":1,"pageTitle":"🧱 Yuml 元素机制详解 (main_block)","url":"/docs/使用教程/mainBlocks#组件元素和普通元素","content":" Yuml 中的元素分为 组件元素 与 普通元素：  普通元素 是由 main_block 函数直接处理的块，如 LOG、FOR、IF 等。组件元素 是 UI 组件中的子元素，统一由cw控制器托管。  组件元素不能在组件外部块中使用，必须定义在如 button、label 等组件块内部。  示例：  button: button1: show: true # 组件元素1 onClicked: buttonClicked # 组件元素2     ","version":"Next","tagName":"h2"},{"title":"📦 通用组件元素和专有组件元素​","type":1,"pageTitle":"🧱 Yuml 元素机制详解 (main_block)","url":"/docs/使用教程/mainBlocks#-通用组件元素和专有组件元素","content":" 组件元素分为：  通用组件元素：适用于所有组件，如 show, size, move, QssStyle；专有组件元素：只适用于特定组件，如 onClicked 是 button 独有。    ","version":"Next","tagName":"h3"},{"title":"📚 通用组件元素支持列表​","type":1,"pageTitle":"🧱 Yuml 元素机制详解 (main_block)","url":"/docs/使用教程/mainBlocks#-通用组件元素支持列表","content":" 以下为组件中通用支持的元素及功能说明：  元素名\t功能show\t控制组件显示/隐藏 move\t设置组件位置（x, y） size\t设置组件大小（width, height） X / Y\t单独设置横/纵坐标位置 width\t设置宽度 height\t设置高度 moveTo\t将组件移动到其他组件的位置 QssStyle\t设置组件样式 id\t设置组件对象名 onMoved\t绑定移动事件 styleTo\t复制另一个组件的样式、状态等 name\t重命名组件全局引用名 onList\t将组件加入指定列表（全局） darkStyle\t设置暗色主题样式 lightStyle\t设置亮色主题样式 parent\t设置父组件 delGlobals\t删除组件对应的全局引用 所有普通元素\t组件元素找不到时会从普通元素里读取  其他不在此表中的会默认从插件(包)中进行读取, 若还没有将抛出id为NoBlockError的ERROR ","version":"Next","tagName":"h2"},{"title":"字符串渲染引擎","type":0,"sectionRef":"#","url":"/docs/使用教程/string","content":"","keywords":"","version":"Next"},{"title":"核心功能​","type":1,"pageTitle":"字符串渲染引擎","url":"/docs/使用教程/string#核心功能","content":" 执行 {&lt;表达式&gt;} 中的代码，默认返回字符串。支持后缀控制返回类型： :obj —— 返回 Python 对象本身:int —— 返回整数类型（将表达式结果转换为 int）    ","version":"Next","tagName":"h2"},{"title":"详细说明​","type":1,"pageTitle":"字符串渲染引擎","url":"/docs/使用教程/string#详细说明","content":" 表达式示例：   - {&lt; 1 + 1 &gt;} → 返回字符串 &quot;2&quot; - {&lt; 1 + 1 &gt;} :int → 返回整数 2 - {&lt; 1 + 1 &gt;} :obj → 返回整数 2（Python 对象）  不会额外增加更多类型转换，避免可读性降低。 复杂类型转换建议使用 :obj，例如： - {&lt; True &gt;} :obj → True (bool 类型) - {&lt; float(1) &gt;} :obj → 1.0 (float 类型) 对象示例：   - {&lt; MyClass() &gt;} → 返回对象的字符串表示，例如 'MyClass' - {&lt; MyClass() &gt;} :obj → 返回对象实例本身 - {&lt; MyClass() &gt;} :int → 会触发 ValueError  转义表达式：   - {&lt;&lt; 1+1 &gt;&gt;} 会被转为 {&lt; 1+1 &gt;}，但不会被执行，类似 Python f-string 中的双括号转义。 - 例如：   - {&lt; 1+1 &gt;} :int → 返回 2 - {&lt;&lt; 1+1 &gt;&gt;} :int → 返回字符串 '{&lt;1+1&gt;} :int'（未执行）  多表达式处理规则：   - {&lt; a &gt;} {&lt; b &gt;} :obj → 返回最后一个表达式的结果，即 b - {&lt; 1 &gt;}{&lt; 2 &gt;} :int → 先拼接为字符串 &quot;12&quot;，再转换为整数 12 - {&lt; 1 &gt;} {&lt; 2 &gt;} :int → 因包含空格，会抛出 ValueError（无法转换 &quot;1 2&quot; 为整数）    ","version":"Next","tagName":"h2"},{"title":"使用示例​","type":1,"pageTitle":"字符串渲染引擎","url":"/docs/使用教程/string#使用示例","content":" LOG: &quot;{&lt; 1+1 &gt;}&quot;   输出： 2    该引擎是 Yuml 的核心功能之一，支持动态表达式渲染，增强了模板的灵活性和扩展性。 ","version":"Next","tagName":"h2"},{"title":"🧠 Yuml 编程基础术语入门","type":0,"sectionRef":"#","url":"/docs/其他/basics","content":"","keywords":"","version":"Next"},{"title":"📌 什么是变量？​","type":1,"pageTitle":"🧠 Yuml 编程基础术语入门","url":"/docs/其他/basics#-什么是变量","content":" 变量就像一个“标签”，你可以把任意值贴在这个标签上，以便之后在程序中多次使用。  在 Yuml 中，定义变量通常使用 \\&gt;：  \\&gt;name: &quot;Yuan&quot; LOG: &quot;Hello, {&lt; name &gt;}!&quot;   这里我们把 &quot;Yuan&quot; 赋值给了变量 name后续你可以通过 {&lt; name &gt;} 来获取它的值输出结果将是：Hello, Yuan!    ","version":"Next","tagName":"h2"},{"title":"📦 什么是块（函数）？​","type":1,"pageTitle":"🧠 Yuml 编程基础术语入门","url":"/docs/其他/basics#-什么是块函数","content":" Yuml 中没有使用 function 或 def 这样的关键词定义函数， 而是把**任意顶格写的块（root 节点）**都当作一个“函数”或“逻辑单元”，我们称之为块（Block）。  greet: LOG: &quot;你好，世界！&quot;   上面的 greet 就是一个自定义块它不会自动执行，需要通过 CALL_BLOCK 来手动调用  调用示例：  windowCreated: CALL_BLOCK: greet     ","version":"Next","tagName":"h2"},{"title":"🔁 如何调用一个块？​","type":1,"pageTitle":"🧠 Yuml 编程基础术语入门","url":"/docs/其他/basics#-如何调用一个块","content":" 调用块有多种方式，最常用的是：  CALL_BLOCK: 适合调用无参或传参块callBlock: 可以调用带多个参数的块  例如：  sayHello: LOG: &quot;你好！&quot; windowCreated: CALL_BLOCK: sayHello     ","version":"Next","tagName":"h2"},{"title":"🌍 什么是全局变量（Globals）？​","type":1,"pageTitle":"🧠 Yuml 编程基础术语入门","url":"/docs/其他/basics#-什么是全局变量globals","content":" 全局变量就像是可以在任何地方使用的共享数据。 你定义一次，全应用都能访问。  定义：  \\&gt;user: &quot;Alice&quot;   使用：  LOG: &quot;当前用户：{&lt; user &gt;}&quot;   全局变量不仅能用于 LOG，也能被 Python/Lua 脚本访问（见 Globals）    ","version":"Next","tagName":"h2"},{"title":"🔧 什么是元素？​","type":1,"pageTitle":"🧠 Yuml 编程基础术语入门","url":"/docs/其他/basics#-什么是元素","content":" Yuml 的每一行（除了块名）都叫做一个“元素”。  例如：  button: myBtn: show: true onClicked: hello   show 是一个通用元素，用于控制组件是否显示onClicked 是一个专有元素，用于响应按钮点击事件  详细请见 元素机制    ","version":"Next","tagName":"h2"},{"title":"🧠 小结​","type":1,"pageTitle":"🧠 Yuml 编程基础术语入门","url":"/docs/其他/basics#-小结","content":" 概念\t在 Yuml 中的形式\t用途变量\t\\&gt;a: 123\t存储数据 块（函数）\tmyFunc:\t封装逻辑 调用\tCALL_BLOCK: myFunc\t触发块运行 全局变量\t所有块共享变量\t跨块传值 元素\tLOG: &quot;abc&quot;\t单行执行语句或设置    如果你从未接触过编程，不用担心！ Yuml 的语法已经简化到了极致，只要你会写 YAML，就能快速上手。 继续阅读文档，一步步了解这个世界吧。 ","version":"Next","tagName":"h2"},{"title":"Jinja2支持","type":0,"sectionRef":"#","url":"/docs/其他/jinja2","content":"","keywords":"","version":"Next"},{"title":"🧠 为什么用 Jinja2？​","type":1,"pageTitle":"Jinja2支持","url":"/docs/其他/jinja2#-为什么用-jinja2","content":" Yuml 是声明式的语言，但并不意味着要放弃灵活性。  借助 Jinja2，你可以在静态结构中加入：  条件判断 ({% if %} / {% else %})循环语句 ({% for %})变量替换 ({{ variable }})宏函数 / include 等模板技巧    ","version":"Next","tagName":"h2"},{"title":"✨ 支持语法示例​","type":1,"pageTitle":"Jinja2支持","url":"/docs/其他/jinja2#-支持语法示例","content":" ; 会根据变量生成不同的内容 {% set show_button = true %} {{ 'BUTTON:' ~ '确认' if show_button else '提示' }} {% for i in range(3) %} LOG: 第 {{ i }} 次执行 {% endfor %}  ","version":"Next","tagName":"h2"},{"title":"🛠️ 开发插件","type":0,"sectionRef":"#","url":"/docs/插件/devPlugin","content":"","keywords":"","version":"Next"},{"title":"1️⃣ 下载插件开发 SDK​","type":1,"pageTitle":"🛠️ 开发插件","url":"/docs/插件/devPlugin#1️⃣-下载插件开发-sdk","content":" Yuml 官方提供了插件开发 SDK：  git clone https://github.com/xYuan20d/Yuml-Package-SDK.git     ","version":"Next","tagName":"h2"},{"title":"2️⃣ 查看目录结构​","type":1,"pageTitle":"🛠️ 开发插件","url":"/docs/插件/devPlugin#2️⃣-查看目录结构","content":" 克隆成功后，你将看到类似的文件结构：  Yuml-Package-SDK/ README.md SDK/ main.py YuanAPI/ YNameSpace.py YAPIS.py __init__.py ...   请将 SDK/ 文件夹移动到你的插件存放目录中，并重命名为你的插件名，例如：  MyPlugin/ main.py YuanAPI/ ...     ","version":"Next","tagName":"h2"},{"title":"3️⃣ 编写插件入口文件​","type":1,"pageTitle":"🛠️ 开发插件","url":"/docs/插件/devPlugin#3️⃣-编写插件入口文件","content":" 打开你重命名后的 main.py，你会看到如下默认代码：  from YuanAPI import YNameSpace Y_NAMESPACE = YNameSpace   Y_NAMESPACE 是插件与 Yuml 解释器通信的桥梁，它是必须存在的变量，不能删除或修改名称。  你可以在此基础上继续添加扩展逻辑，如注册组件、元素、钩子等。    ","version":"Next","tagName":"h2"},{"title":"📘 SDK 文档​","type":1,"pageTitle":"🛠️ 开发插件","url":"/docs/插件/devPlugin#-sdk-文档","content":" 关于 SDK 中可用的接口、事件钩子、扩展方式等，请参考：插件 SDK 文档    ","version":"Next","tagName":"h2"},{"title":"✅ 至此，你的插件开发环境已经准备就绪！​","type":1,"pageTitle":"🛠️ 开发插件","url":"/docs/插件/devPlugin#-至此你的插件开发环境已经准备就绪","content":" 你现在可以开始使用 Yuml 插件机制，开发属于你自己的组件、指令、扩展模块等内容。  推荐继续阅读以下文档：  加载/使用插件插件 SDK ","version":"Next","tagName":"h2"},{"title":"🔌 加载 / 使用插件","type":0,"sectionRef":"#","url":"/docs/插件/usePlugin","content":"","keywords":"","version":"Next"},{"title":"📦 插件加载机制​","type":1,"pageTitle":"🔌 加载 / 使用插件","url":"/docs/插件/usePlugin#-插件加载机制","content":" 与传统语言按“单个插件/模块加载”的方式不同，Yuml 是通过指定整个插件目录来一次性加载多个插件。  Yuml 会自动遍历该目录下的所有子文件夹，并识别其中的插件内容。    ","version":"Next","tagName":"h2"},{"title":"🧭 如何加载插件目录？​","type":1,"pageTitle":"🔌 加载 / 使用插件","url":"/docs/插件/usePlugin#-如何加载插件目录","content":" 使用 IMPORT 元素来指定插件所在目录名：  IMPORT: 插件文件夹名   示例：  假设你的插件目录结构如下：  plugins/ MyPlugin1/ main.py MyPlugin2/ main.py   那么只需写：  IMPORT: plugins   Yuml 会自动遍历 plugins 文件夹，并识别所有子目录下的 main.py 插件文件。    ","version":"Next","tagName":"h2"},{"title":"🧰 插件能做什么？​","type":1,"pageTitle":"🔌 加载 / 使用插件","url":"/docs/插件/usePlugin#-插件能做什么","content":" Yuml 插件机制非常灵活，支持以下几种扩展能力：  ","version":"Next","tagName":"h2"},{"title":"✅ 扩展组件元素（通过cw控制器）​","type":1,"pageTitle":"🔌 加载 / 使用插件","url":"/docs/插件/usePlugin#-扩展组件元素通过cw控制器","content":" 你可以为现有组件（如 button、label 等）添加新的元素行为，示例：  button: btn1: myCustomAttr: true   在插件中通过cw控制器注册即可生效。    ","version":"Next","tagName":"h3"},{"title":"✅ 扩展普通元素​","type":1,"pageTitle":"🔌 加载 / 使用插件","url":"/docs/插件/usePlugin#-扩展普通元素","content":" 你可以自定义一个新的顶级元素，如：  MyNewElement: ...   然后在插件中通过普通元素注册机制接管该逻辑。    ","version":"Next","tagName":"h3"},{"title":"✅ 注册新的组件类型​","type":1,"pageTitle":"🔌 加载 / 使用插件","url":"/docs/插件/usePlugin#-注册新的组件类型","content":" 插件还可以通过cw控制器注册全新的组件类型，使得你可以扩展 UI 控件系统。    ","version":"Next","tagName":"h3"},{"title":"📘 小结​","type":1,"pageTitle":"🔌 加载 / 使用插件","url":"/docs/插件/usePlugin#-小结","content":" 功能\t插件中实现方式扩展组件元素\t使用cw控制器 扩展普通元素\t注册元素处理函数 自定义新组件\t注册组件构造逻辑    插件机制是 Yuml 的强大扩展方式，配合 Globals 与 块机制，可以构建出复杂且灵活的系统架构。 如果你正在开发自己的组件或框架，推荐使用插件方式封装逻辑。  提示 当多个插件定义了相同名称的元素时，Yuml 会自动进行命名冲突处理，避免相互覆盖。 具体规则如下： 如果插件 A 和插件 B 都定义了名为 test 的元素，且 B 在 A 之后加载， 那么 B 插件中的元素将被自动重命名为： test_B 这样可以确保两个插件的定义互不干扰。 ✅ 这是 Yuml 插件系统的默认行为，无需手动处理。 ","version":"Next","tagName":"h2"},{"title":"SDK介绍","type":0,"sectionRef":"#","url":"/docs/插件/插件SDK/pluginSDK","content":"SDK介绍 待更新","keywords":"","version":"Next"},{"title":"Yuml 独有的基本概念","type":0,"sectionRef":"#","url":"/docs/使用教程/concept","content":"","keywords":"","version":"Next"},{"title":"1. 块（Block）与元素（Element）​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#1-块block与元素element","content":" 在 Yuml 中，每个根节点（Root）下都是一个“块”（Block）。块是 Yuml 的基本代码结构单元，用于封装逻辑、组件或数据内容。  ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#示例","content":" a: _: 1 b: _: 1 _2: 1   上例中，a 和 b 都是块，分别称为「a 块」和「b 块」。每个块中的键值对称为元素（Element）。a 块中包含一个元素：_，值为 1。b 块中包含两个元素：_ 和 _2，值均为 1。  ","version":"Next","tagName":"h3"},{"title":"组件元素​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#组件元素","content":" 参考: 组件元素和普通元素    ","version":"Next","tagName":"h3"},{"title":"2. Globals（全局变量）​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#2-globals全局变量","content":" Globals 是 Yuml 中最核心的概念之一。 它的设计理念是：在一个地方设置后，整个系统中所有语言层都可以同步访问。  这意味着，无论是 YAML 脚本本身，还是 Python、Lua 等脚本语言，都可以共享访问同一个变量。  ","version":"Next","tagName":"h2"},{"title":"🔄 多语言同步示例​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#-多语言同步示例","content":" 以下示例展示了如何通过 Globals 实现变量在多个语言环境中的共享：  \\&gt;a: 1 LOG: &quot;{&lt; a &gt;}&quot; PythonScript: &quot;print(a)&quot; LuaScript: &quot;print(a)&quot;   输出：  1 1 1   在上例中，\\&gt;a: 1 定义了一个名为 a 的全局变量：  {&lt; a &gt;} 用于字符串渲染引擎中访问 aPython 和 Lua 脚本中直接访问同名变量 a，无需额外传参  ","version":"Next","tagName":"h3"},{"title":"💡 其他创建 Globals 的方式​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#-其他创建-globals-的方式","content":" HOOK 元素在执行时也会创建对应的全局变量某些组件行为、回调处理等也可能隐式地将变量注入为 Globals  ","version":"Next","tagName":"h3"},{"title":"🧹 生命周期与管理​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#-生命周期与管理","content":" Globals 的生命周期 贯穿整个应用运行期间，不会自动销毁若需要手动清除变量，可使用 DELETE 元素进行删除：  DELETE: - a   ","version":"Next","tagName":"h3"},{"title":"📘 延伸阅读​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#-延伸阅读","content":" 字符串渲染引擎中的 {&lt; a &gt;} 表达式同样依赖 Globals 提供变量支持，详见： 字符串渲染引擎  掌握 Globals 是 Yuml 编程的入门基础，也是数据交互的核心机制之一。    ","version":"Next","tagName":"h3"},{"title":"3.HOOK —— 捕获返回值的机制​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#3hook--捕获返回值的机制","content":" 在 Yuml 中，每个元素或块都可能产生返回值。 但如果你不使用 HOOK，这个返回值将被自动忽略。  使用 HOOK，可以将返回值赋值给一个变量名（全局变量），用于后续逻辑中使用。 如果该元素/块没有返回值，则默认返回 None。  ","version":"Next","tagName":"h2"},{"title":"🧾 HOOK 的两种写法​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#-hook-的两种写法","content":" ✅ 标准写法​  HOOK: result: _test: 10 # 假设 _test 元素会返回 10 LOG: &quot;{&lt; result &gt;}&quot; # 输出 10   ✅ 简洁写法（推荐）​  \\#result: _test: 10 LOG: &quot;{&lt; result &gt;}&quot; # 输出 10   这两种写法功能完全一致，简洁写法更方便快捷。  ","version":"Next","tagName":"h3"},{"title":"📦 块也有返回值​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#-块也有返回值","content":" 每个块（Block）也支持返回值，使用 RETURN 元素返回一个结果。  你可以结合 CALL_BLOCK 与 HOOK 捕获块的返回值：  windowCreated: \\#value: CALL_BLOCK: testBlock LOG: &quot;{&lt; value &gt;}&quot; # 输出 test testBlock: RETURN: &quot;test&quot;   ","version":"Next","tagName":"h3"},{"title":"📘 小提示​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#-小提示","content":" HOOK 创建的是Globals，所以你可以在任何位置通过 {&lt; 名称 &gt;} 获取值。多数元素（如组件创建、逻辑判断）都支持 HOOK 捕获。即使元素返回的是 None，也会正常创建对应的变量。  HOOK 是构建复杂逻辑时必不可少的机制，建议熟练掌握。    ","version":"Next","tagName":"h3"},{"title":"4️. .accept 参数机制​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#4️-accept-参数机制","content":" Yuml 中的 \\&gt; 语法通常用于通过 eval 动态定义变量，例如：  \\&gt;a: 1   但你可能不知道，a 也可以赋值为特殊值 .accept，以实现块的“参数传递”功能。  ","version":"Next","tagName":"h2"},{"title":"📦 什么是 .accept？​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#-什么是-accept","content":" 在 Yuml 中，每个块都支持类似函数的参数机制，不过默认情况下不会启用。 只有当你在块内部使用 \\&gt;变量名: .accept 语句时，Yuml 才会将外部传入的值赋给该变量。  ","version":"Next","tagName":"h3"},{"title":"✨ 示例​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#-示例","content":" windowCreated: CALL_BLOCK: [&quot;testBlock&quot;, &quot;hello world&quot;] testBlock: \\&gt;items: .accept LOG: &quot;{&lt; items &gt;}&quot; # 输出 hello world   解释：  CALL_BLOCK 第二个参数 &quot;hello world&quot; 会被作为参数传入 testBlock在 testBlock 中，items 被定义为 .accept，因此自动获得传入值  ","version":"Next","tagName":"h3"},{"title":"⚠️ 注意事项​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#️-注意事项","content":" 每个块只能接收一个参数值如果你需要传递多个值，请将它们打包成一个列表或对象  CALL_BLOCK: [&quot;testBlock&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]]   ","version":"Next","tagName":"h3"},{"title":"🧠 补充说明​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#-补充说明","content":" .accept 机制不会默认生效，必须在块内部显式声明 \\&gt;变量: .accept.accept 机制未传递参数时会赋值为None(null)这是 Yuml 提供的一种简洁函数参数绑定方式，特别适合用于逻辑块、模板块等  推荐与 HOOK 搭配使用，实现输入参数 → 返回值的完整封装模式。    ","version":"Next","tagName":"h3"},{"title":"5️. 控制流​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#5️-控制流","content":" 虽然 Yuml 是一门声明式语言，但它拥有完善的控制流机制，远超多数声明语言的能力。 它支持：  IF 条件判断（包含 ELSE 与多条件模拟 ELIF）FOR 循环WHILE 循环以及 BREAK / CONTINUE 关键控制语句  这些控制流语法，让 Yuml 拥有接近编程语言的逻辑表达能力。  ","version":"Next","tagName":"h2"},{"title":"🔁 FOR 循环示例​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#-for-循环示例","content":" FOR: ITER: range(10) # 注意：ITER 中的内容会自动使用 eval 执行 Python 表达式 NAME: i CODE: LOG: &quot;{&lt; i &gt;}&quot;   输出 0 到 9 的数字（每行一个）  ","version":"Next","tagName":"h3"},{"title":"🧠 IF 条件判断示例​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#-if-条件判断示例","content":" \\&gt;age: 18 IF: age &gt;= 18: LOG: &quot;成年&quot; ELSE: LOG: &quot;未成年&quot;   ","version":"Next","tagName":"h3"},{"title":"➕ 多分支判断（模拟 elif）​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#-多分支判断模拟-elif","content":" Yuml 不直接提供 elif，但你可以通过多个判断键模拟：  IF: age &gt;= 22: LOG: &quot;到达法定结婚年龄&quot; age &gt;= 18: LOG: &quot;成年&quot; ELSE: LOG: &quot;未成年&quot;   Yuml 会从上到下依次判断条件，只执行第一个满足条件的分支。  ","version":"Next","tagName":"h3"},{"title":"🧭 更多内容​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#-更多内容","content":" WHILE 循环BREAK / CONTINUE 跳出循环控制ELSE 分支逻辑RETURN 控制块返回值  请查看完整文档：控制流详解  控制流是 Yuml 脱离传统 XML/HTML 样式系统，迈向“有逻辑的声明式语言”的关键部分，建议务必掌握。    ","version":"Next","tagName":"h3"},{"title":"6️. 字符串渲染​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#6️-字符串渲染","content":" 字符串渲染是 Yuml 的核心机制之一。 你可能已经注意到，很多元素的值中可以包含 {&lt;&gt;} 这样的表达式，这并不是普通的字符串插值，而是一套强大的 “字符串 + 代码混合执行机制”。  ","version":"Next","tagName":"h2"},{"title":"✨ 渲染机制简介​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#-渲染机制简介","content":" Yuml 在运行时会对所有字符串中出现的 {&lt; 表达式 &gt;} 进行自动识别，并通过 正则 + eval 执行，将其转译为对应的值。  例如：  \\&gt;a: 2 LOG: &quot;结果是 {&lt; a + 3 &gt;}&quot; # 输出：结果是 5   ","version":"Next","tagName":"h3"},{"title":"📘 更多特性​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#-更多特性","content":" 支持 :int、:obj 等后缀控制返回类型多表达式渲染{{&lt;&lt; &gt;&gt;}} 转义机制（防止渲染）支持表达式嵌套和列表拼接等高级语法  详细语法规则请查阅完整文档：字符串渲染引擎  小贴士 几乎所有元素值在执行前都会自动经过字符串渲染引擎处理。    ","version":"Next","tagName":"h3"},{"title":"7️. 前后端交互特性​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#7️-前后端交互特性","content":" Yuml 原生支持 前后端分离式开发：  前端：使用 Yuml 编写 UI 逻辑后端：使用 Python 编写业务逻辑  通过简单的配置，你可以轻松将前端事件与 Python 函数连接起来，构建动态交互的桌面应用。  ","version":"Next","tagName":"h2"},{"title":"🚩 启用前后端交互​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#-启用前后端交互","content":" 你需要通过 $app::setPython 元素绑定 Python 后端文件：  $app::setPython: [[&quot;test&quot;], {}] # test.py 会自动被导入并用于交互   ","version":"Next","tagName":"h3"},{"title":"🧩 后端 Python 编写​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#-后端-python-编写","content":" 你的 Python 文件（如 test.py）中，需要定义一个 APP 类并继承内置的 YAPP：  from YUML.YmlAPIS.python import YAPP class APP(YAPP): ...   注意 必须继承自 YAPP，否则 Yuml 无法识别你的类！  ","version":"Next","tagName":"h3"},{"title":"🎯 使用按钮触发交互（示例）​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#-使用按钮触发交互示例","content":" Yuml 前端文件：  button: button1: show: true onClicked: button1_clicked   test.py 后端文件：  class APP(YAPP): def __init__(self, raw): self.raw = raw def button1_clicked(self, info): button = info[0] # 第一个参数是被点击的按钮对象 button.setText(&quot;按钮被点击！&quot;)   ","version":"Next","tagName":"h3"},{"title":"📚 更多玩法​","type":1,"pageTitle":"Yuml 独有的基本概念","url":"/docs/使用教程/concept#-更多玩法","content":" 你可以在前端的 按钮、某些事件块 等处调用后端 Python 函数，实现更复杂的交互逻辑。 详见：前后端交互完整文档  Yuml 的交互机制完全基于反射，开发者几乎不需要额外桥接代码，函数名对上即可自动绑定，极大提升开发效率。 ","version":"Next","tagName":"h3"}],"options":{"languages":["zh","en"],"highlightResult":true,"maxHits":10,"indexBaseUrl":true,"fields":{"title":{"boost":200},"content":{"boost":2},"keywords":{"boost":100}},"id":"default"}}